---
title: "Montovan Style Bee Simulation"
output: html_notebook
---

```{r}
library(tidyverse)
library(forcats)
library(reshape2)
library(R6)
library(av)
```

Define variables
```{r Variables}
BROOD <- 1
POLLEN <- 2
HONEY <- 3 
EMPTY <- 0

MAX_ROWS <- 75
MAX_COLS <- 45

source("Bee Parameters.R")
```

Makes the beehive graph framework
https://stackoverflow.com/questions/24006361/plot-series-of-filled-hexagons-in-ggplot2
```{r Beehive Graph}

types <- c("Brood", "Pollen", "Honey", "Empty")
#hive_colors <- c("#F3DAB1","#FFF966","#DE620B","#230F11")
hive_colors <- c("#FF0000","#00FF00","#0000FF","#000000")

hex_size <- 1

hex_center_xs <- rep_len(c(seq(from = 0, by = hex_size, length.out = MAX_COLS),
                   seq(from = hex_size/2, by = hex_size, length.out = MAX_COLS)), MAX_ROWS*MAX_COLS)

hex_center_ys <- sort(c(rep(seq(from = 0, by = hex_size*sqrt(3), length.out=ceiling(MAX_ROWS/2)), MAX_COLS),
            rep(seq(from = hex_size*sqrt(3)/2, by = hex_size*sqrt(3), length.out=floor(MAX_ROWS/2)), MAX_COLS)),decreasing = TRUE)

hex_x = cbind(hex_center_xs + 0, hex_center_xs + 0.5, hex_center_xs + 0.5,
              hex_center_xs + 0, hex_center_xs - 0.5, hex_center_xs - 0.5) 
hex_y = cbind(hex_center_ys - 1/(sqrt(3)), hex_center_ys - 1/(2*sqrt(3)), hex_center_ys + 1/(2*sqrt(3)),
              hex_center_ys + 1/(sqrt(3)), hex_center_ys + 1/(2*sqrt(3)), hex_center_ys - 1/(2*sqrt(3)))

hexdat_x <- melt(cbind(id = 1:length(hex_center_xs), as.data.frame(hex_x)), id.vars = "id", value.name = "x")
hexdat_y <- melt(cbind(id = 1:length(hex_center_ys), as.data.frame(hex_y)), id.vars = "id", value.name = "y")

hexdat <- full_join(hexdat_y, hexdat_x)

hex_center_xs_df <- melt(cbind(id = 1:length(hex_center_xs), as.data.frame(hex_center_xs)), id.vars = "id", value.name = "x") %>% select(-variable)
hex_center_ys_df <- melt(cbind(id = 1:length(hex_center_ys), as.data.frame(hex_center_ys)), id.vars = "id", value.name = "y") %>% select(-variable)

hexdat_centers <- full_join(hex_center_xs_df, hex_center_ys_df, by = "id") %>% mutate(Xind = ((id-1)%%MAX_COLS)+1,
                                                                                      Yind = ceiling(id/MAX_COLS))

MAX_X <- max(hex_center_xs)
MAX_Y <- max(hex_center_ys)


```

This takes a given hive and turns it into a graph

```{r Hive to Graph}

hive_matrix_to_graph <- function(hive_data,queen){
  hive_tbl <- as.table(hive[,,1:2])
  colnames(hive_tbl) <- 1:MAX_COLS
  rownames(hive_tbl) <- 1:MAX_ROWS
  hive_df_pre <- as.data.frame(hive_tbl)
  hive_df <- as.data.frame(hive_tbl) %>% pivot_wider(names_from = Var3, values_from = Freq)
  colnames(hive_df) <- c("y","x","contents","amount")
  hive_df <- hive_df %>% arrange(y) %>%
                         mutate(id = 1:(MAX_COLS*MAX_ROWS)) %>% 
                         mutate(named_content = ifelse(contents == 0, "Empty",
                                                       ifelse(contents == 1, "Brood",
                                                              ifelse(contents == 2, "Pollen",
                                                                     ifelse(contents == 3, "Honey","???")))))
  new_hexdat <- full_join(hexdat,
                          hive_df %>% select(id,named_content,amount),
                          by="id") %>% mutate(named_content = fct_relevel(as.factor(named_content),types))
  
  new_hexdat <- new_hexdat %>% mutate(amount = ifelse(named_content == "Honey",amount/MAX_HONEY,
                                                      ifelse(named_content == "Pollen",amount/MAX_POLLEN,
                                                             ifelse(named_content == "Brood",amount/MAX_BROOD,1))))
  
  #Adding Queen to the Graph
  queen_locs <- matrix(EMPTY,MAX_ROWS,MAX_COLS)
  
  queen_locs[queen$cur_X,queen$cur_Y] <- 1
  
  colnames(queen_locs) <- 1:MAX_COLS
  rownames(queen_locs) <- 1:MAX_ROWS
  
  queen_locs <- as.data.frame(as.table(queen_locs))
  
  colnames(queen_locs) <- c("col","row","is_bee")
  queen_locs <- queen_locs %>% mutate(id = 1:(MAX_COLS*MAX_ROWS))
  
  new_queen_locs <- full_join(hexdat_centers,queen_locs,by = "id") %>% filter(is_bee == 1)
                            
  g <- ggplot() + 
        geom_polygon(new_hexdat, mapping = aes(x,y,group = id, fill = named_content, alpha = amount), colour = "black") +
        scale_fill_manual(values=hive_colors) +
        coord_fixed() +
        theme_classic()
  
  return(g)
}
```

```{r}
make_random_hive <- function(){
  layer1 <- sample(c(EMPTY,BROOD,HONEY,POLLEN), MAX_ROWS*MAX_COLS, replace = TRUE, prob = c(0.1,0,1,1))
  
  #Second two rows are for brood honey and pollen
  rand_hive <- array(c(layer1,rep(EMPTY,MAX_ROWS*MAX_COLS),
                       rep(0,MAX_ROWS*MAX_COLS),
                       rep(0,MAX_ROWS*MAX_COLS)), dim = c(MAX_ROWS,MAX_COLS, 4))
  
  for(x in 1:MAX_COLS){
    for(y in 1:MAX_ROWS){
      layer2_val <- ifelse(rand_hive[y,x,1] == BROOD, sample(1:MAX_BROOD, 1),
                          ifelse(rand_hive[y,x,1] == HONEY, sample(1:MAX_HONEY,1),
                                 ifelse(rand_hive[y,x,1] == POLLEN, sample(1:MAX_POLLEN,1),
                                        0)))
      rand_hive[x,y,2] <- layer2_val
    }
  }
  
  return(rand_hive)
}
```

Moving through hexagons (https://www.redblobgames.com/grids/hexagons/)
If we store the hexagon values in a 2D grid we need to know which "squares" are actually next to each other on a hexagonal grid

On a square grid we can move from [X,Y] to [X+1,Y], [X-1,Y], [X,Y+1], and [X,Y-1], if we remove diagonals

On a hexagonal grid (using what they call “odd-r” horizontal layout) we can move from [X,Y] to:
    [X-1,Y-1], [X-1,Y], [X-1,Y+1], [X,Y+1], [X+1,Y], [X,Y-1]
    
But that's *just* for the odd rows (1 indexed). For the even rows it's: 
    [X,Y-1], [X-1,Y], [X,Y+1], [X+1,Y+1], [X+1,Y], [X+1,Y-1]

```{r Hex Movement}

hex_move <- function(cur_X,cur_Y,prev_X,prev_Y){
  even_row_legal_hexes <- tibble(
                                x = c(cur_X,cur_X-1,cur_X,cur_X+1,cur_X+1,cur_X+1),
                                y = c(cur_Y-1,cur_Y,cur_Y+1,cur_Y+1,cur_Y,cur_Y-1)
                               )
  odd_row_legal_hexes <- tibble(
                                x = c(cur_X-1,cur_X-1,cur_X-1,cur_X,cur_X+1,cur_X),
                                y = c(cur_Y-1,cur_Y,cur_Y+1,cur_Y+1,cur_Y,cur_Y-1)
                               )
  
  #check if our row is even or odd
  if(cur_Y %% 2 == 0){
    legal_hexes <- even_row_legal_hexes
  }
  else{
    legal_hexes <- odd_row_legal_hexes
  }
  
  #Makes sure it can't move back to where it was, or to the last square it was on
  #Also R is 1 indexed, so it can't be 0 or less
  legal_hexes <- legal_hexes %>% filter(x > 0) %>% filter(y > 0) %>%
                                 filter(x <= MAX_ROWS) %>% filter(y <= MAX_COLS) %>%
                                 filter(!(x == prev_X & y == prev_Y))
  
  next_hex <- legal_hexes %>% sample_n(1)
  
  return(c(next_hex$x,next_hex$y))
}

```

To find the nearest hex to a point
```{r Nearest Hex Index to Point}
nearest_hex <- function(xLoc,yLoc){
  hex_dist <- hexdat_centers %>% mutate(dist = sqrt((xLoc-x)**2+(yLoc-y)**2)) %>% arrange(dist)
  return(c(hex_dist$Xind[1],hex_dist$Yind[1]))
}
```

To find all hexes within a radius of a point
```{r All Hexes in Radius of a Point}
hexes_in_rad <- function(xLoc,yLoc,rad){
  hex_dist <- hexdat_centers %>% mutate(dist = sqrt((xLoc-x)**2+(yLoc-y)**2)) %>% filter(dist <= rad)
  return(list(hex_dist$Xind,hex_dist$Yind))
}
```

To get distance to nearest hex that contains specific contents
```{r Nearest Hex with specific content}
hexes_nearest_contents <- function(xLoc,yLoc,content,hive_data){
  hex_dist <- hexdat_centers %>% mutate(dist = sqrt((xLoc-x)**2+(yLoc-y)**2))
  
  hive_df <- as.data.frame(as.table(hive_data[,,1:2])) %>% pivot_wider(names_from = Var3, values_from = Freq)
  colnames(hive_df) <- c("x","y","contents","amount")
  hive_df <- hive_df %>% mutate(id = 1:(MAX_COLS*MAX_ROWS))
  
  new_hex_dist <- full_join(hex_dist,
                            hive_df %>% select(id,contents),
                            by="id") %>% filter(contents == content) %>% arrange(dist)
  
  return(c(new_hex_dist$Xind[1],new_hex_dist$Yind[1]))
}
```

Brood Density Calculation

Something is wrong with the way I treat x and y here and I do hate it, but I'll fix it later. For now they are swapped
```{r Get Brood Density}

NECTER_CONSUMP_RAD <- 4

get_brood_density <- function(x_ind,y_ind,hive_data){
  xLoc <- (hexdat_centers %>% filter(Xind == x_ind, Yind == y_ind))$x
  yLoc <- (hexdat_centers %>% filter(Xind == x_ind, Yind == y_ind))$y
  
  hex_dist <- hexdat_centers %>% mutate(dist = sqrt((xLoc-x)**2+(yLoc-y)**2))
  
  hive_df <- as.data.frame(as.table(hive_data[,,1:2])) %>% pivot_wider(names_from = Var3, values_from = Freq)
  colnames(hive_df) <- c("x","y","contents","amount")
  hive_df <- hive_df %>% mutate(id = 1:(MAX_COLS*MAX_ROWS))
  
  new_hex_dist <- full_join(hex_dist,
                            hive_df %>% select(id,contents),
                            by="id") %>% filter(contents == BROOD) %>% filter(dist < NECTER_CONSUMP_RAD)
  
  distance_to_all_brood <- sum(new_hex_dist$dist)
  
  return(distance_to_all_brood/(3*NECTER_CONSUMP_RAD*(NECTER_CONSUMP_RAD+1)))
}

```


To set up the hive

"Unless specified, each model run was initiated with a completely full comb with an ideal pattern of a center region of brood, surrounded by a ring of pollen, and honey in all remaining cells. The assignment of type to each cell is deterministic and constant across all simulations. The brood region is a circular disk centered in the middle of the comb with radius 18 cell lengths. Around this brood region is a ring of pollen 4 cell lengths wide. The rest of the comb is filled with honey."

```{r Determined Hive Setup}

make_set_hive <- function(){
  BROOD_RADIUS <- 18
  POLLEN_WIDTH <- 4
  
  #Second two rows are for brood honey and pollen
  set_hive <- array(c(rep(HONEY,MAX_ROWS*MAX_COLS),
                      rep(0,MAX_ROWS*MAX_COLS*2)),
                    dim = c(MAX_ROWS,MAX_COLS, 3))
  
  all_to_pollen <- hexes_in_rad(MAX_X/2,MAX_Y/2,BROOD_RADIUS+POLLEN_WIDTH)
  
  for(i in 1:length(all_to_pollen[[1]])){
    x <- all_to_pollen[[1]][i]
    y <- all_to_pollen[[2]][i]
    set_hive[y,x,1] <- POLLEN
  }
  
  all_to_brood <- hexes_in_rad(MAX_X/2,MAX_Y/2,BROOD_RADIUS)
  
  for(i in 1:length(all_to_brood[[1]])){
    x <- all_to_brood[[1]][i]
    y <- all_to_brood[[2]][i]
    set_hive[y,x,1] <- BROOD
  }
  
  for(x in 1:MAX_COLS){
    for(y in 1:MAX_ROWS){
      layer2_val <- ifelse(set_hive[y,x,1] == BROOD, sample(1:MAX_BROOD, 1),
                          ifelse(set_hive[y,x,1] == HONEY, sample(1:MAX_HONEY,1),
                                 ifelse(set_hive[y,x,1] == POLLEN, sample(1:MAX_POLLEN,1),
                                        0)))
      layer3_val <- ifelse(set_hive[y,x,1] == BROOD, sample(1:24, 1), 0)
      
      set_hive[y,x,2] <- layer2_val
      set_hive[y,x,3] <- layer3_val
    }
  }
  
  return(set_hive)
}

```

For adding products by the worker bees
```{r collecting honey and pollen}

N_ATTEMPTS <- 6

collect_products <- function(hive_data,product,product_max){
  for(i in 1:N_ATTEMPTS){
    rand_x <- sample(1:MAX_COLS,1)
    rand_y <- sample(1:MAX_ROWS,1)
    
    if(hive_data[rand_y,rand_x,1] == product && hive_data[rand_y,rand_x,2] < product_max){
      hive_data[rand_y,rand_x,2] <- hive_data[rand_y,rand_x,2] + 1
      break
    } else if(hive_data[rand_y,rand_x,1] == EMPTY){
      hive_data[rand_y,rand_x,1] <- product
      hive_data[rand_y,rand_x,2] <- 1
      break
    }
  }
  return(hive_data)
}

```

For Eating Pollen and Honey

Here k is the Ratio of honey/pollen taken from cells fully surrounded by brood cells to honey/pollen taken from cells with no brood neighbors (dimensionless)
```{r}

k <- 10

eat_products <- function(hive_data,product){
  for(i in 1:N_ATTEMPTS){
    rand_x <- sample(1:MAX_COLS,1)
    rand_y <- sample(1:MAX_ROWS,1)
    
    if(hive_data[rand_y,rand_x,1] == product){
      hive_data[rand_y,rand_x,2] <- hive_data[rand_y,rand_x,2] - min(hive_data[rand_y,rand_x,2],
                                                                     1 + get_brood_density(rand_x,rand_y,hive_data)*(k-1))
      if(hive_data[rand_y,rand_x,2] == 0){
        hive_data[rand_y,rand_x,1] <- EMPTY
      }
      break
    }
  }
  return(hive_data)
}

```


For Brood Aging
```{r Brood Aging}

# We don't hatch them here, we hatch them hourly
age_brood <- function(hive_data){
  #Get the x and y of all brood
  brood_xs <- data.frame(which(hive_data[,,1] == BROOD,arr.ind = TRUE))$col
  brood_ys <- data.frame(which(hive_data[,,1] == BROOD,arr.ind = TRUE))$row
  
  for(i in 1:length(brood_xs)){
    hive_data[brood_ys[i],brood_xs[i],2] <- hive_data[brood_ys[i],brood_xs[i],2] + 1
  }
 return(hive_data)
}

```

Determines brood hatching
```{r Brood Hatching}

hatch_brood <- function(hive_data,hour){
  hatch_x <- data.frame(which(hive_data[,,1] == BROOD & hive_data[,,2] >= MAX_BROOD & hive_data[,,3] == hour,arr.ind = TRUE))$col
  hatch_y <- data.frame(which(hive_data[,,1] == BROOD & hive_data[,,2] >= MAX_BROOD & hive_data[,,3] == hour,arr.ind = TRUE))$row
  
  #Hatch all brood that hatch this hour
  for(i in 1:length(hatch_x)){
    hive_data[hatch_y[i],hatch_x[i],1] <- EMPTY
    hive_data[hatch_y[i],hatch_x[i],2] <- 0
    hive_data[hatch_y[i],hatch_x[i],3] <- 0
  }
  
  return(hive_data)
}

```


### Hive levels
1. Contents (Honey, Pollen, Brood, Empty)
2. Amount (For Brood it's the age)
3. Brood hourly hatching cohort

```{r Run Simulation, warning = FALSE}
hive <- make_set_hive()

DAYS <- 10

for(d in 1:DAYS){
#24 hours in a day
  for(h in 1:24){
    #Now add the right amount of products
    for(i in 1:HONEY_BY_HOUR){
      hive <- collect_products(hive,HONEY,MAX_HONEY)
    }
    for(i in 1:POLLEN_BY_HOUR){
      hive <- collect_products(hive,POLLEN,MAX_POLLEN)
    }
    
    #Now we hatch the bees
    hive <- hatch_brood(hive,h)
    
    #Now we have bees eat
    for(i in 1:HONEY_EATEN_PER_HOUR){
      hive <- eat_products(hive,HONEY)
    }
    for(i in 1:POLLEN_EATEN_PER_HOUR){
      hive <- eat_products(hive,POLLEN)
    }
    
    #Now graph for that hour
    ggsave(paste0("hive_plots/hiveplot_",str_pad((d-1)*24+h, 5, pad = "0"),
                  "_D",str_pad(d, 3, pad = "0"),".png"),
           hive_matrix_to_graph(hive,c()),width=7, height=7)
  }
  hive <- age_brood(hive)
}

```


Turn images into video
```{r Images to Video}
productPath <- ('/Users/Ben/Desktop/Bee-Simulation/hive_plots/')
av::av_encode_video(paste0(productPath,list.files(productPath, '*.png')), framerate = 10,
                    output = paste0("hive_videos/bee_video_only_eat_D",DAYS,"_H",HONEY_BY_HOUR,
                                    "_P",POLLEN_BY_HOUR,"_Q",QUEEN_CELLS_PER_HOUR,".mp4"))
```


```{r}

consumption_tibble <- tibble(xVal = sample(1:MAX_COLS,1000,replace = TRUE),
                             yVal = sample(1:MAX_ROWS,1000,replace = TRUE))
  
consumption_tibble <- consumption_tibble %>% mutate(eaten = 1 + get_brood_density(yVal,xVal,hive)*(k-1))

```

