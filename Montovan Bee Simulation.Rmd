---
title: "Montovan Style Bee Simulation"
output: html_notebook
---

```{r}
library(tidyverse)
library(forcats)
library(reshape2)
library(R6)
library(av)
```

Define variables
```{r Variables}
BROOD <- 1
POLLEN <- 2
HONEY <- 3 
EMPTY <- 0

MAX_ROWS <- 75
MAX_COLS <- 45

source("Bee Parameters.R")
```

Makes the beehive graph framework
https://stackoverflow.com/questions/24006361/plot-series-of-filled-hexagons-in-ggplot2
```{r Beehive Graph}

types <- c("Brood", "Pollen", "Honey", "Empty")
#hive_colors <- c("#F3DAB1","#FFF966","#DE620B","#230F11")
hive_colors <- c("#FF0000","#00FF00","#0000FF","#000000")

hex_size <- 1

hex_center_xs <- rep_len(c(seq(from = 0, by = hex_size, length.out = MAX_COLS),
                   seq(from = hex_size/2, by = hex_size, length.out = MAX_COLS)), MAX_ROWS*MAX_COLS)

hex_center_ys <- sort(c(rep(seq(from = 0, by = hex_size*sqrt(3), length.out=ceiling(MAX_ROWS/2)), MAX_COLS),
            rep(seq(from = hex_size*sqrt(3)/2, by = hex_size*sqrt(3), length.out=floor(MAX_ROWS/2)), MAX_COLS)),decreasing = TRUE)

hex_x = cbind(hex_center_xs + 0, hex_center_xs + 0.5, hex_center_xs + 0.5,
              hex_center_xs + 0, hex_center_xs - 0.5, hex_center_xs - 0.5) 
hex_y = cbind(hex_center_ys - 1/(sqrt(3)), hex_center_ys - 1/(2*sqrt(3)), hex_center_ys + 1/(2*sqrt(3)),
              hex_center_ys + 1/(sqrt(3)), hex_center_ys + 1/(2*sqrt(3)), hex_center_ys - 1/(2*sqrt(3)))

hexdat_x <- melt(cbind(id = 1:length(hex_center_xs), as.data.frame(hex_x)), id.vars = "id", value.name = "x")
hexdat_y <- melt(cbind(id = 1:length(hex_center_ys), as.data.frame(hex_y)), id.vars = "id", value.name = "y")

hexdat <- full_join(hexdat_y, hexdat_x)

hex_center_xs_df <- melt(cbind(id = 1:length(hex_center_xs), as.data.frame(hex_center_xs)), id.vars = "id", value.name = "x") %>% select(-variable)
hex_center_ys_df <- melt(cbind(id = 1:length(hex_center_ys), as.data.frame(hex_center_ys)), id.vars = "id", value.name = "y") %>% select(-variable)

hexdat_centers <- full_join(hex_center_xs_df, hex_center_ys_df, by = "id") %>% mutate(Xind = ((id-1)%%MAX_COLS)+1,
                                                                                      Yind = ceiling(id/MAX_COLS))

MAX_X <- max(hex_center_xs)
MAX_Y <- max(hex_center_ys)


```

This takes a given hive and turns it into a graph

```{r Hive to Graph}

hive_matrix_to_graph <- function(hive_data,queen){
  hive_tbl <- as.table(hive_data[,,1:2])
  colnames(hive_tbl) <- 1:MAX_COLS
  rownames(hive_tbl) <- 1:MAX_ROWS
  hive_df_pre <- as.data.frame(hive_tbl)
  hive_df <- as.data.frame(hive_tbl) %>% pivot_wider(names_from = Var3, values_from = Freq)
  colnames(hive_df) <- c("y","x","contents","amount")
  hive_df <- hive_df %>% arrange(y) %>%
                         mutate(id = 1:(MAX_COLS*MAX_ROWS)) %>% 
                         mutate(named_content = ifelse(contents == 0, "Empty",
                                                       ifelse(contents == 1, "Brood",
                                                              ifelse(contents == 2, "Pollen",
                                                                     ifelse(contents == 3, "Honey","???")))))
  new_hexdat <- full_join(hexdat,
                          hive_df %>% select(id,named_content,amount),
                          by="id") %>% mutate(named_content = fct_relevel(as.factor(named_content),types))
  
  new_hexdat <- new_hexdat %>% mutate(amount = ifelse(named_content == "Honey",amount/MAX_HONEY,
                                                      ifelse(named_content == "Pollen",amount/MAX_POLLEN,
                                                             ifelse(named_content == "Brood",amount/MAX_BROOD,1))))
  
  #Adding Queen to the Graph
  queen_locs <- matrix(EMPTY,MAX_ROWS,MAX_COLS)
  
  queen_locs[queen$cur_X,queen$cur_Y] <- 1
  
  colnames(queen_locs) <- 1:MAX_COLS
  rownames(queen_locs) <- 1:MAX_ROWS
  
  queen_locs <- as.data.frame(as.table(queen_locs))
  
  colnames(queen_locs) <- c("col","row","is_bee")
  queen_locs <- queen_locs %>% mutate(id = 1:(MAX_COLS*MAX_ROWS))
  
  new_queen_locs <- full_join(hexdat_centers,queen_locs,by = "id") %>% filter(is_bee == 1)
                            
  g <- ggplot() + 
        geom_polygon(new_hexdat, mapping = aes(x,y,group = id, fill = named_content, alpha = amount), colour = "black") +
        scale_fill_manual(values=hive_colors) +
        coord_fixed() +
        theme_classic()
  
  return(g)
}
```

```{r}
make_random_hive <- function(){
  layer1 <- sample(c(EMPTY,BROOD,HONEY,POLLEN), MAX_ROWS*MAX_COLS, replace = TRUE, prob = c(0.1,0,1,1))
  
  #Second two rows are for brood honey and pollen
  rand_hive <- array(c(layer1,rep(EMPTY,MAX_ROWS*MAX_COLS),
                       rep(0,MAX_ROWS*MAX_COLS),
                       rep(0,MAX_ROWS*MAX_COLS)), dim = c(MAX_ROWS,MAX_COLS, 4))
  
  for(x in 1:MAX_ROWS){
    for(y in 1:MAX_COLS){
      layer2_val <- ifelse(rand_hive[x,y,1] == BROOD, sample(1:MAX_BROOD, 1),
                          ifelse(rand_hive[x,y,1] == HONEY, sample(1:MAX_HONEY,1),
                                 ifelse(rand_hive[x,y,1] == POLLEN, sample(1:MAX_POLLEN,1),
                                        0)))
      rand_hive[x,y,2] <- layer2_val
    }
  }
  
  return(rand_hive)
}
```

Moving through hexagons (https://www.redblobgames.com/grids/hexagons/)
If we store the hexagon values in a 2D grid we need to know which "squares" are actually next to each other on a hexagonal grid

On a square grid we can move from [X,Y] to [X+1,Y], [X-1,Y], [X,Y+1], and [X,Y-1], if we remove diagonals

On a hexagonal grid (using what they call “odd-r” horizontal layout) we can move from [X,Y] to:
    [X-1,Y-1], [X-1,Y], [X-1,Y+1], [X,Y+1], [X+1,Y], [X,Y-1]
    
But that's *just* for the odd rows (1 indexed). For the even rows it's: 
    [X,Y-1], [X-1,Y], [X,Y+1], [X+1,Y+1], [X+1,Y], [X+1,Y-1]

```{r Hex Movement}

hex_move <- function(cur_X,cur_Y,prev_X,prev_Y){
  even_row_legal_hexes <- tibble(
                                x = c(cur_X,cur_X-1,cur_X,cur_X+1,cur_X+1,cur_X+1),
                                y = c(cur_Y-1,cur_Y,cur_Y+1,cur_Y+1,cur_Y,cur_Y-1)
                               )
  odd_row_legal_hexes <- tibble(
                                x = c(cur_X-1,cur_X-1,cur_X-1,cur_X,cur_X+1,cur_X),
                                y = c(cur_Y-1,cur_Y,cur_Y+1,cur_Y+1,cur_Y,cur_Y-1)
                               )
  
  #check if our row is even or odd
  if(cur_Y %% 2 == 0){
    legal_hexes <- even_row_legal_hexes
  }
  else{
    legal_hexes <- odd_row_legal_hexes
  }
  
  #Makes sure it can't move back to where it was, or to the last square it was on
  #Also R is 1 indexed, so it can't be 0 or less
  legal_hexes <- legal_hexes %>% filter(x > 0) %>% filter(y > 0) %>%
                                 filter(x <= MAX_ROWS) %>% filter(y <= MAX_COLS) %>%
                                 filter(!(x == prev_X & y == prev_Y))
  
  next_hex <- legal_hexes %>% sample_n(1)
  
  return(c(next_hex$x,next_hex$y))
}

```

To find the nearest hex to a point
```{r Nearest Hex Index to Point}
nearest_hex <- function(xLoc,yLoc){
  hex_dist <- hexdat_centers %>% mutate(dist = sqrt((xLoc-x)**2+(yLoc-y)**2)) %>% arrange(dist)
  return(c(hex_dist$Xind[1],hex_dist$Yind[1]))
}
```

To find all hexes within a radius of a point
```{r All Hexes in Radius of a Point}
hexes_in_rad <- function(xLoc,yLoc,rad){
  hex_dist <- hexdat_centers %>% mutate(dist = sqrt((xLoc-x)**2+(yLoc-y)**2)) %>% filter(dist <= rad)
  return(list(hex_dist$Xind,hex_dist$Yind))
}
```

To get distance to nearest hex that contains specific contents
```{r Nearest Hex with specific content}
hexes_nearest_contents <- function(xLoc,yLoc,content,hive_data){
  hex_dist <- hexdat_centers %>% mutate(dist = sqrt((xLoc-x)**2+(yLoc-y)**2))
  
  hive_df <- as.data.frame(as.table(hive_data[,,1:2])) %>% pivot_wider(names_from = Var3, values_from = Freq)
  colnames(hive_df) <- c("x","y","contents","amount")
  hive_df <- hive_df %>% mutate(id = 1:(MAX_COLS*MAX_ROWS))
  
  new_hex_dist <- full_join(hex_dist,
                            hive_df %>% select(id,contents),
                            by="id") %>% filter(contents == content) %>% arrange(dist)
  
  return(c(new_hex_dist$Xind[1],new_hex_dist$Yind[1]))
}
```
To set up the hive

"Unless specified, each model run was initiated with a completely full comb with an ideal pattern of a center region of brood, surrounded by a ring of pollen, and honey in all remaining cells. The assignment of type to each cell is deterministic and constant across all simulations. The brood region is a circular disk centered in the middle of the comb with radius 18 cell lengths. Around this brood region is a ring of pollen 4 cell lengths wide. The rest of the comb is filled with honey."

```{r Determined Hive Setup}

make_set_hive <- function(){
  BROOD_RADIUS <- 18
  POLLEN_WIDTH <- 4
  
  #Second two rows are for brood honey and pollen
  set_hive <- array(rep(HONEY,MAX_ROWS*MAX_COLS*2), dim = c(MAX_ROWS,MAX_COLS, 2))
  
  all_to_pollen <- hexes_in_rad(MAX_X/2,MAX_Y/2,BROOD_RADIUS+POLLEN_WIDTH)
  
  for(i in 1:length(all_to_pollen[[1]])){
    x <- all_to_pollen[[2]][i]
    y <- all_to_pollen[[1]][i]
    set_hive[x,y,1] <- POLLEN
  }
  
  all_to_brood <- hexes_in_rad(MAX_X/2,MAX_Y/2,BROOD_RADIUS)
  
  for(i in 1:length(all_to_brood[[1]])){
    x <- all_to_brood[[2]][i]
    y <- all_to_brood[[1]][i]
    set_hive[x,y,1] <- BROOD
  }
  
  for(x in 1:MAX_ROWS){
    for(y in 1:MAX_COLS){
      layer2_val <- ifelse(set_hive[x,y,1] == BROOD, sample(1:MAX_BROOD, 1),
                          ifelse(set_hive[x,y,1] == HONEY, sample(1:MAX_HONEY,1),
                                 ifelse(set_hive[x,y,1] == POLLEN, sample(1:MAX_POLLEN,1),
                                        0)))
      set_hive[x,y,2] <- layer2_val
    }
  }
  
  return(set_hive)
}

#hive <- array(rep(0,MAX_ROWS*MAX_COLS*2), dim = c(MAX_ROWS,MAX_COLS, 2))
#hive[40,25,1] <- BROOD
hive <- make_set_hive()
hive_matrix_to_graph(hive,c())

```


For Brood Aging
```{r}

age_brood <- function(hive_data){
  #Get the x and y of all brood
  brood_xs <- data.frame(which(hive_data[,,1] == BROOD,arr.ind = TRUE))$row
  brood_ys <- data.frame(which(hive_data[,,1] == BROOD,arr.ind = TRUE))$col
  
  for(i in 1:length(brood_xs)){
    if(hive_data[brood_xs[i],brood_ys[i],2] < MAX_BROOD-1){
      #If they aren't about to become max age add 1 to age
      hive_data[brood_xs[i],brood_ys[i],2] <- hive_data[brood_xs[i],brood_ys[i],2] + 1
      hive_data[brood_xs[i],brood_ys[i],3] <- 0
      hive_data[brood_xs[i],brood_ys[i],4] <- 0
    } else{
      #If they are then empty it out
      hive_data[brood_xs[i],brood_ys[i],1] <- EMPTY
      hive_data[brood_xs[i],brood_ys[i],2] <- 0
      hive_data[brood_xs[i],brood_ys[i],3] <- 0
      hive_data[brood_xs[i],brood_ys[i],4] <- 0
    }
  }
 return(hive_data)
}

```




